// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/base/common.proto

package pb

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AIStrategy int32

const (
	AIStrategy_AIStrategy_None             AIStrategy = 0
	AIStrategy_AIStrategy_CompleteGameFlow AIStrategy = 1
	AIStrategy_AIStrategy_Normal           AIStrategy = 2
	AIStrategy_AIStrategy_Hard             AIStrategy = 3
	AIStrategy_AIStrategy_JuniorAssistant  AIStrategy = 4
)

var AIStrategy_name = map[int32]string{
	0: "AIStrategy_None",
	1: "AIStrategy_CompleteGameFlow",
	2: "AIStrategy_Normal",
	3: "AIStrategy_Hard",
	4: "AIStrategy_JuniorAssistant",
}

var AIStrategy_value = map[string]int32{
	"AIStrategy_None":             0,
	"AIStrategy_CompleteGameFlow": 1,
	"AIStrategy_Normal":           2,
	"AIStrategy_Hard":             3,
	"AIStrategy_JuniorAssistant":  4,
}

func (x AIStrategy) String() string {
	return proto.EnumName(AIStrategy_name, int32(x))
}

func (AIStrategy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_da8d4bc57760a4b8, []int{0}
}

type CardEffect int32

const (
	CardEffect_CardEffect_None    CardEffect = 0
	CardEffect_CardEffect_Destory CardEffect = 1
	CardEffect_CardEffect_Reveal  CardEffect = 4
)

var CardEffect_name = map[int32]string{
	0: "CardEffect_None",
	1: "CardEffect_Destory",
	4: "CardEffect_Reveal",
}

var CardEffect_value = map[string]int32{
	"CardEffect_None":    0,
	"CardEffect_Destory": 1,
	"CardEffect_Reveal":  4,
}

func (x CardEffect) String() string {
	return proto.EnumName(CardEffect_name, int32(x))
}

func (CardEffect) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_da8d4bc57760a4b8, []int{1}
}

// 匹配、对局模式
type MatchMode int32

const (
	MatchMode_MatchMode_None   MatchMode = 0
	MatchMode_MatchMode_Normal MatchMode = 1
	MatchMode_MatchMode_Topic  MatchMode = 2
)

var MatchMode_name = map[int32]string{
	0: "MatchMode_None",
	1: "MatchMode_Normal",
	2: "MatchMode_Topic",
}

var MatchMode_value = map[string]int32{
	"MatchMode_None":   0,
	"MatchMode_Normal": 1,
	"MatchMode_Topic":  2,
}

func (x MatchMode) String() string {
	return proto.EnumName(MatchMode_name, int32(x))
}

func (MatchMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_da8d4bc57760a4b8, []int{2}
}

// 登录渠道
type LoginChannel int32

const (
	LoginChannel_LoginChannel_None LoginChannel = 0
	LoginChannel_LoginChannel_Qoo  LoginChannel = 1
)

var LoginChannel_name = map[int32]string{
	0: "LoginChannel_None",
	1: "LoginChannel_Qoo",
}

var LoginChannel_value = map[string]int32{
	"LoginChannel_None": 0,
	"LoginChannel_Qoo":  1,
}

func (x LoginChannel) String() string {
	return proto.EnumName(LoginChannel_name, int32(x))
}

func (LoginChannel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_da8d4bc57760a4b8, []int{3}
}

type MailState int32

const (
	MailState_MailUnRead   MailState = 0
	MailState_MailRead     MailState = 1
	MailState_MailReceived MailState = 2
)

var MailState_name = map[int32]string{
	0: "MailUnRead",
	1: "MailRead",
	2: "MailReceived",
}

var MailState_value = map[string]int32{
	"MailUnRead":   0,
	"MailRead":     1,
	"MailReceived": 2,
}

func (x MailState) String() string {
	return proto.EnumName(MailState_name, int32(x))
}

func (MailState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_da8d4bc57760a4b8, []int{4}
}

type MailType int32

const (
	MailType_MailDefined  MailType = 0
	MailType_MailTemplate MailType = 1
)

var MailType_name = map[int32]string{
	0: "MailDefined",
	1: "MailTemplate",
}

var MailType_value = map[string]int32{
	"MailDefined":  0,
	"MailTemplate": 1,
}

func (x MailType) String() string {
	return proto.EnumName(MailType_name, int32(x))
}

func (MailType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_da8d4bc57760a4b8, []int{5}
}

type PayChannel int32

const (
	PayChannel_PayChannel_None   PayChannel = 0
	PayChannel_PayChannel_Qoo    PayChannel = 1
	PayChannel_PayChannel_Apple  PayChannel = 2
	PayChannel_PayChannel_Google PayChannel = 3
)

var PayChannel_name = map[int32]string{
	0: "PayChannel_None",
	1: "PayChannel_Qoo",
	2: "PayChannel_Apple",
	3: "PayChannel_Google",
}

var PayChannel_value = map[string]int32{
	"PayChannel_None":   0,
	"PayChannel_Qoo":    1,
	"PayChannel_Apple":  2,
	"PayChannel_Google": 3,
}

func (x PayChannel) String() string {
	return proto.EnumName(PayChannel_name, int32(x))
}

func (PayChannel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_da8d4bc57760a4b8, []int{6}
}

type CardInfo struct {
	CardId         int32 `protobuf:"varint,1,opt,name=cardId,proto3" json:"cardId,omitempty"`
	CardCp         int32 `protobuf:"varint,2,opt,name=cardCp,proto3" json:"cardCp,omitempty"`
	CardEffect     int32 `protobuf:"varint,3,opt,name=cardEffect,proto3" json:"cardEffect,omitempty"`
	AffectedCounts int32 `protobuf:"varint,4,opt,name=affectedCounts,proto3" json:"affectedCounts,omitempty"`
	AreaId         int32 `protobuf:"varint,5,opt,name=areaId,proto3" json:"areaId,omitempty"`
}

func (m *CardInfo) Reset()         { *m = CardInfo{} }
func (m *CardInfo) String() string { return proto.CompactTextString(m) }
func (*CardInfo) ProtoMessage()    {}
func (*CardInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_da8d4bc57760a4b8, []int{0}
}
func (m *CardInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CardInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CardInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CardInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CardInfo.Merge(m, src)
}
func (m *CardInfo) XXX_Size() int {
	return m.Size()
}
func (m *CardInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CardInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CardInfo proto.InternalMessageInfo

func (m *CardInfo) GetCardId() int32 {
	if m != nil {
		return m.CardId
	}
	return 0
}

func (m *CardInfo) GetCardCp() int32 {
	if m != nil {
		return m.CardCp
	}
	return 0
}

func (m *CardInfo) GetCardEffect() int32 {
	if m != nil {
		return m.CardEffect
	}
	return 0
}

func (m *CardInfo) GetAffectedCounts() int32 {
	if m != nil {
		return m.AffectedCounts
	}
	return 0
}

func (m *CardInfo) GetAreaId() int32 {
	if m != nil {
		return m.AreaId
	}
	return 0
}

type AreaInfo struct {
	AreaId     int32 `protobuf:"varint,1,opt,name=areaId,proto3" json:"areaId,omitempty"`
	Cp         int32 `protobuf:"varint,2,opt,name=cp,proto3" json:"cp,omitempty"`
	CardCounts int32 `protobuf:"varint,3,opt,name=cardCounts,proto3" json:"cardCounts,omitempty"`
}

func (m *AreaInfo) Reset()         { *m = AreaInfo{} }
func (m *AreaInfo) String() string { return proto.CompactTextString(m) }
func (*AreaInfo) ProtoMessage()    {}
func (*AreaInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_da8d4bc57760a4b8, []int{1}
}
func (m *AreaInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AreaInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AreaInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AreaInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AreaInfo.Merge(m, src)
}
func (m *AreaInfo) XXX_Size() int {
	return m.Size()
}
func (m *AreaInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AreaInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AreaInfo proto.InternalMessageInfo

func (m *AreaInfo) GetAreaId() int32 {
	if m != nil {
		return m.AreaId
	}
	return 0
}

func (m *AreaInfo) GetCp() int32 {
	if m != nil {
		return m.Cp
	}
	return 0
}

func (m *AreaInfo) GetCardCounts() int32 {
	if m != nil {
		return m.CardCounts
	}
	return 0
}

type ScoreInfo struct {
	Score           int32   `protobuf:"varint,1,opt,name=score,proto3" json:"score,omitempty"`
	DoubleScore     int32   `protobuf:"varint,2,opt,name=doubleScore,proto3" json:"doubleScore,omitempty"`
	ConditionScores []int32 `protobuf:"varint,3,rep,packed,name=conditionScores,proto3" json:"conditionScores,omitempty"`
}

func (m *ScoreInfo) Reset()         { *m = ScoreInfo{} }
func (m *ScoreInfo) String() string { return proto.CompactTextString(m) }
func (*ScoreInfo) ProtoMessage()    {}
func (*ScoreInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_da8d4bc57760a4b8, []int{2}
}
func (m *ScoreInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScoreInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScoreInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScoreInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScoreInfo.Merge(m, src)
}
func (m *ScoreInfo) XXX_Size() int {
	return m.Size()
}
func (m *ScoreInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ScoreInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ScoreInfo proto.InternalMessageInfo

func (m *ScoreInfo) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *ScoreInfo) GetDoubleScore() int32 {
	if m != nil {
		return m.DoubleScore
	}
	return 0
}

func (m *ScoreInfo) GetConditionScores() []int32 {
	if m != nil {
		return m.ConditionScores
	}
	return nil
}

type CardDetailInfo struct {
	CardId  int32 `protobuf:"varint,1,opt,name=card_id,json=cardId,proto3" json:"card_id,omitempty"`
	Lv      int32 `protobuf:"varint,2,opt,name=lv,proto3" json:"lv,omitempty"`
	CurIcon int32 `protobuf:"varint,3,opt,name=curIcon,proto3" json:"curIcon,omitempty"`
}

func (m *CardDetailInfo) Reset()         { *m = CardDetailInfo{} }
func (m *CardDetailInfo) String() string { return proto.CompactTextString(m) }
func (*CardDetailInfo) ProtoMessage()    {}
func (*CardDetailInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_da8d4bc57760a4b8, []int{3}
}
func (m *CardDetailInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CardDetailInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CardDetailInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CardDetailInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CardDetailInfo.Merge(m, src)
}
func (m *CardDetailInfo) XXX_Size() int {
	return m.Size()
}
func (m *CardDetailInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CardDetailInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CardDetailInfo proto.InternalMessageInfo

func (m *CardDetailInfo) GetCardId() int32 {
	if m != nil {
		return m.CardId
	}
	return 0
}

func (m *CardDetailInfo) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *CardDetailInfo) GetCurIcon() int32 {
	if m != nil {
		return m.CurIcon
	}
	return 0
}

type Deck struct {
	Id        int32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CardList  []int32 `protobuf:"varint,2,rep,packed,name=cardList,proto3" json:"cardList,omitempty"`
	CreatTime int64   `protobuf:"varint,3,opt,name=creatTime,proto3" json:"creatTime,omitempty"`
	Name      string  `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	BackSkin  int32   `protobuf:"varint,5,opt,name=backSkin,proto3" json:"backSkin,omitempty"`
	Titles    int32   `protobuf:"varint,6,opt,name=titles,proto3" json:"titles,omitempty"`
	Avatar    int32   `protobuf:"varint,7,opt,name=avatar,proto3" json:"avatar,omitempty"`
}

func (m *Deck) Reset()         { *m = Deck{} }
func (m *Deck) String() string { return proto.CompactTextString(m) }
func (*Deck) ProtoMessage()    {}
func (*Deck) Descriptor() ([]byte, []int) {
	return fileDescriptor_da8d4bc57760a4b8, []int{4}
}
func (m *Deck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deck.Merge(m, src)
}
func (m *Deck) XXX_Size() int {
	return m.Size()
}
func (m *Deck) XXX_DiscardUnknown() {
	xxx_messageInfo_Deck.DiscardUnknown(m)
}

var xxx_messageInfo_Deck proto.InternalMessageInfo

func (m *Deck) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Deck) GetCardList() []int32 {
	if m != nil {
		return m.CardList
	}
	return nil
}

func (m *Deck) GetCreatTime() int64 {
	if m != nil {
		return m.CreatTime
	}
	return 0
}

func (m *Deck) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Deck) GetBackSkin() int32 {
	if m != nil {
		return m.BackSkin
	}
	return 0
}

func (m *Deck) GetTitles() int32 {
	if m != nil {
		return m.Titles
	}
	return 0
}

func (m *Deck) GetAvatar() int32 {
	if m != nil {
		return m.Avatar
	}
	return 0
}

type SeasonInfo struct {
	SeasonId int32 `protobuf:"varint,1,opt,name=season_id,json=seasonId,proto3" json:"season_id,omitempty"`
	Score    int32 `protobuf:"varint,2,opt,name=score,proto3" json:"score,omitempty"`
	Grade    int32 `protobuf:"varint,3,opt,name=grade,proto3" json:"grade,omitempty"`
	Ranking  int32 `protobuf:"varint,4,opt,name=ranking,proto3" json:"ranking,omitempty"`
}

func (m *SeasonInfo) Reset()         { *m = SeasonInfo{} }
func (m *SeasonInfo) String() string { return proto.CompactTextString(m) }
func (*SeasonInfo) ProtoMessage()    {}
func (*SeasonInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_da8d4bc57760a4b8, []int{5}
}
func (m *SeasonInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SeasonInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SeasonInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SeasonInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SeasonInfo.Merge(m, src)
}
func (m *SeasonInfo) XXX_Size() int {
	return m.Size()
}
func (m *SeasonInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SeasonInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SeasonInfo proto.InternalMessageInfo

func (m *SeasonInfo) GetSeasonId() int32 {
	if m != nil {
		return m.SeasonId
	}
	return 0
}

func (m *SeasonInfo) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *SeasonInfo) GetGrade() int32 {
	if m != nil {
		return m.Grade
	}
	return 0
}

func (m *SeasonInfo) GetRanking() int32 {
	if m != nil {
		return m.Ranking
	}
	return 0
}

type RoomPlayerInfo struct {
	Uid           string              `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Name          string              `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	CardGroupInfo []*CardDetailInfo   `protobuf:"bytes,3,rep,name=cardGroupInfo,proto3" json:"cardGroupInfo,omitempty"`
	Ai            AIStrategy          `protobuf:"varint,4,opt,name=ai,proto3,enum=AIStrategy" json:"ai,omitempty"`
	Head          int32               `protobuf:"varint,5,opt,name=head,proto3" json:"head,omitempty"`
	AreaInfo      map[int32]*AreaInfo `protobuf:"bytes,6,rep,name=areaInfo,proto3" json:"areaInfo,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	DeckInfo      *Deck               `protobuf:"bytes,7,opt,name=deckInfo,proto3" json:"deckInfo,omitempty"`
	ScoreInfo     *ScoreInfo          `protobuf:"bytes,8,opt,name=scoreInfo,proto3" json:"scoreInfo,omitempty"`
	SeasonInfo    *SeasonInfo         `protobuf:"bytes,9,opt,name=seasonInfo,proto3" json:"seasonInfo,omitempty"`
}

func (m *RoomPlayerInfo) Reset()         { *m = RoomPlayerInfo{} }
func (m *RoomPlayerInfo) String() string { return proto.CompactTextString(m) }
func (*RoomPlayerInfo) ProtoMessage()    {}
func (*RoomPlayerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_da8d4bc57760a4b8, []int{6}
}
func (m *RoomPlayerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomPlayerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomPlayerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoomPlayerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomPlayerInfo.Merge(m, src)
}
func (m *RoomPlayerInfo) XXX_Size() int {
	return m.Size()
}
func (m *RoomPlayerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomPlayerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RoomPlayerInfo proto.InternalMessageInfo

func (m *RoomPlayerInfo) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *RoomPlayerInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RoomPlayerInfo) GetCardGroupInfo() []*CardDetailInfo {
	if m != nil {
		return m.CardGroupInfo
	}
	return nil
}

func (m *RoomPlayerInfo) GetAi() AIStrategy {
	if m != nil {
		return m.Ai
	}
	return AIStrategy_AIStrategy_None
}

func (m *RoomPlayerInfo) GetHead() int32 {
	if m != nil {
		return m.Head
	}
	return 0
}

func (m *RoomPlayerInfo) GetAreaInfo() map[int32]*AreaInfo {
	if m != nil {
		return m.AreaInfo
	}
	return nil
}

func (m *RoomPlayerInfo) GetDeckInfo() *Deck {
	if m != nil {
		return m.DeckInfo
	}
	return nil
}

func (m *RoomPlayerInfo) GetScoreInfo() *ScoreInfo {
	if m != nil {
		return m.ScoreInfo
	}
	return nil
}

func (m *RoomPlayerInfo) GetSeasonInfo() *SeasonInfo {
	if m != nil {
		return m.SeasonInfo
	}
	return nil
}

type CardEvent struct {
	EffectId CardEffect `protobuf:"varint,1,opt,name=effectId,proto3,enum=CardEffect" json:"effectId,omitempty"`
	EventVal int32      `protobuf:"varint,2,opt,name=eventVal,proto3" json:"eventVal,omitempty"`
}

func (m *CardEvent) Reset()         { *m = CardEvent{} }
func (m *CardEvent) String() string { return proto.CompactTextString(m) }
func (*CardEvent) ProtoMessage()    {}
func (*CardEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_da8d4bc57760a4b8, []int{7}
}
func (m *CardEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CardEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CardEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CardEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CardEvent.Merge(m, src)
}
func (m *CardEvent) XXX_Size() int {
	return m.Size()
}
func (m *CardEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_CardEvent.DiscardUnknown(m)
}

var xxx_messageInfo_CardEvent proto.InternalMessageInfo

func (m *CardEvent) GetEffectId() CardEffect {
	if m != nil {
		return m.EffectId
	}
	return CardEffect_CardEffect_None
}

func (m *CardEvent) GetEventVal() int32 {
	if m != nil {
		return m.EventVal
	}
	return 0
}

type RoundPlayerInfo struct {
	Uid       string       `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Card      []*CardInfo  `protobuf:"bytes,2,rep,name=card,proto3" json:"card,omitempty"`
	CardEvent []*CardEvent `protobuf:"bytes,3,rep,name=cardEvent,proto3" json:"cardEvent,omitempty"`
	Ai        AIStrategy   `protobuf:"varint,4,opt,name=ai,proto3,enum=AIStrategy" json:"ai,omitempty"`
}

func (m *RoundPlayerInfo) Reset()         { *m = RoundPlayerInfo{} }
func (m *RoundPlayerInfo) String() string { return proto.CompactTextString(m) }
func (*RoundPlayerInfo) ProtoMessage()    {}
func (*RoundPlayerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_da8d4bc57760a4b8, []int{8}
}
func (m *RoundPlayerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoundPlayerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoundPlayerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoundPlayerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoundPlayerInfo.Merge(m, src)
}
func (m *RoundPlayerInfo) XXX_Size() int {
	return m.Size()
}
func (m *RoundPlayerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RoundPlayerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RoundPlayerInfo proto.InternalMessageInfo

func (m *RoundPlayerInfo) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *RoundPlayerInfo) GetCard() []*CardInfo {
	if m != nil {
		return m.Card
	}
	return nil
}

func (m *RoundPlayerInfo) GetCardEvent() []*CardEvent {
	if m != nil {
		return m.CardEvent
	}
	return nil
}

func (m *RoundPlayerInfo) GetAi() AIStrategy {
	if m != nil {
		return m.Ai
	}
	return AIStrategy_AIStrategy_None
}

type ItemInfo struct {
	ItemId  int32 `protobuf:"varint,1,opt,name=item_id,json=itemId,proto3" json:"item_id,omitempty"`
	ItemNum int32 `protobuf:"varint,2,opt,name=item_num,json=itemNum,proto3" json:"item_num,omitempty"`
}

func (m *ItemInfo) Reset()         { *m = ItemInfo{} }
func (m *ItemInfo) String() string { return proto.CompactTextString(m) }
func (*ItemInfo) ProtoMessage()    {}
func (*ItemInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_da8d4bc57760a4b8, []int{9}
}
func (m *ItemInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemInfo.Merge(m, src)
}
func (m *ItemInfo) XXX_Size() int {
	return m.Size()
}
func (m *ItemInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ItemInfo proto.InternalMessageInfo

func (m *ItemInfo) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *ItemInfo) GetItemNum() int32 {
	if m != nil {
		return m.ItemNum
	}
	return 0
}

// 邮件
type MailBrief struct {
	Id          int64       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	MailType    MailType    `protobuf:"varint,2,opt,name=mailType,proto3,enum=MailType" json:"mailType,omitempty"`
	State       MailState   `protobuf:"varint,3,opt,name=state,proto3,enum=MailState" json:"state,omitempty"`
	Theme       string      `protobuf:"bytes,4,opt,name=theme,proto3" json:"theme,omitempty"`
	Time        int64       `protobuf:"varint,5,opt,name=time,proto3" json:"time,omitempty"`
	EndTime     int64       `protobuf:"varint,6,opt,name=endTime,proto3" json:"endTime,omitempty"`
	CfgId       int32       `protobuf:"varint,7,opt,name=cfgId,proto3" json:"cfgId,omitempty"`
	Attachments []*ItemInfo `protobuf:"bytes,8,rep,name=attachments,proto3" json:"attachments,omitempty"`
}

func (m *MailBrief) Reset()         { *m = MailBrief{} }
func (m *MailBrief) String() string { return proto.CompactTextString(m) }
func (*MailBrief) ProtoMessage()    {}
func (*MailBrief) Descriptor() ([]byte, []int) {
	return fileDescriptor_da8d4bc57760a4b8, []int{10}
}
func (m *MailBrief) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MailBrief) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MailBrief.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MailBrief) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MailBrief.Merge(m, src)
}
func (m *MailBrief) XXX_Size() int {
	return m.Size()
}
func (m *MailBrief) XXX_DiscardUnknown() {
	xxx_messageInfo_MailBrief.DiscardUnknown(m)
}

var xxx_messageInfo_MailBrief proto.InternalMessageInfo

func (m *MailBrief) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MailBrief) GetMailType() MailType {
	if m != nil {
		return m.MailType
	}
	return MailType_MailDefined
}

func (m *MailBrief) GetState() MailState {
	if m != nil {
		return m.State
	}
	return MailState_MailUnRead
}

func (m *MailBrief) GetTheme() string {
	if m != nil {
		return m.Theme
	}
	return ""
}

func (m *MailBrief) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *MailBrief) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *MailBrief) GetCfgId() int32 {
	if m != nil {
		return m.CfgId
	}
	return 0
}

func (m *MailBrief) GetAttachments() []*ItemInfo {
	if m != nil {
		return m.Attachments
	}
	return nil
}

type Mail struct {
	Brief    *MailBrief `protobuf:"bytes,1,opt,name=brief,proto3" json:"brief,omitempty"`
	Msg      string     `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	SenderId string     `protobuf:"bytes,3,opt,name=senderId,proto3" json:"senderId,omitempty"`
}

func (m *Mail) Reset()         { *m = Mail{} }
func (m *Mail) String() string { return proto.CompactTextString(m) }
func (*Mail) ProtoMessage()    {}
func (*Mail) Descriptor() ([]byte, []int) {
	return fileDescriptor_da8d4bc57760a4b8, []int{11}
}
func (m *Mail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Mail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Mail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Mail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Mail.Merge(m, src)
}
func (m *Mail) XXX_Size() int {
	return m.Size()
}
func (m *Mail) XXX_DiscardUnknown() {
	xxx_messageInfo_Mail.DiscardUnknown(m)
}

var xxx_messageInfo_Mail proto.InternalMessageInfo

func (m *Mail) GetBrief() *MailBrief {
	if m != nil {
		return m.Brief
	}
	return nil
}

func (m *Mail) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *Mail) GetSenderId() string {
	if m != nil {
		return m.SenderId
	}
	return ""
}

// redis 通知
type RedisNotifyNewWorldMail struct {
	Data string `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *RedisNotifyNewWorldMail) Reset()         { *m = RedisNotifyNewWorldMail{} }
func (m *RedisNotifyNewWorldMail) String() string { return proto.CompactTextString(m) }
func (*RedisNotifyNewWorldMail) ProtoMessage()    {}
func (*RedisNotifyNewWorldMail) Descriptor() ([]byte, []int) {
	return fileDescriptor_da8d4bc57760a4b8, []int{12}
}
func (m *RedisNotifyNewWorldMail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RedisNotifyNewWorldMail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RedisNotifyNewWorldMail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RedisNotifyNewWorldMail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedisNotifyNewWorldMail.Merge(m, src)
}
func (m *RedisNotifyNewWorldMail) XXX_Size() int {
	return m.Size()
}
func (m *RedisNotifyNewWorldMail) XXX_DiscardUnknown() {
	xxx_messageInfo_RedisNotifyNewWorldMail.DiscardUnknown(m)
}

var xxx_messageInfo_RedisNotifyNewWorldMail proto.InternalMessageInfo

func (m *RedisNotifyNewWorldMail) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type RedisNotifyNewPlayerMail struct {
	Uid   string `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	MaiId int64  `protobuf:"varint,2,opt,name=maiId,proto3" json:"maiId,omitempty"`
}

func (m *RedisNotifyNewPlayerMail) Reset()         { *m = RedisNotifyNewPlayerMail{} }
func (m *RedisNotifyNewPlayerMail) String() string { return proto.CompactTextString(m) }
func (*RedisNotifyNewPlayerMail) ProtoMessage()    {}
func (*RedisNotifyNewPlayerMail) Descriptor() ([]byte, []int) {
	return fileDescriptor_da8d4bc57760a4b8, []int{13}
}
func (m *RedisNotifyNewPlayerMail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RedisNotifyNewPlayerMail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RedisNotifyNewPlayerMail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RedisNotifyNewPlayerMail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedisNotifyNewPlayerMail.Merge(m, src)
}
func (m *RedisNotifyNewPlayerMail) XXX_Size() int {
	return m.Size()
}
func (m *RedisNotifyNewPlayerMail) XXX_DiscardUnknown() {
	xxx_messageInfo_RedisNotifyNewPlayerMail.DiscardUnknown(m)
}

var xxx_messageInfo_RedisNotifyNewPlayerMail proto.InternalMessageInfo

func (m *RedisNotifyNewPlayerMail) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *RedisNotifyNewPlayerMail) GetMaiId() int64 {
	if m != nil {
		return m.MaiId
	}
	return 0
}

type RedisNotify struct {
	NewWorldMail  *RedisNotifyNewWorldMail  `protobuf:"bytes,1,opt,name=newWorldMail,proto3" json:"newWorldMail,omitempty"`
	NewPlayerMail *RedisNotifyNewPlayerMail `protobuf:"bytes,2,opt,name=newPlayerMail,proto3" json:"newPlayerMail,omitempty"`
}

func (m *RedisNotify) Reset()         { *m = RedisNotify{} }
func (m *RedisNotify) String() string { return proto.CompactTextString(m) }
func (*RedisNotify) ProtoMessage()    {}
func (*RedisNotify) Descriptor() ([]byte, []int) {
	return fileDescriptor_da8d4bc57760a4b8, []int{14}
}
func (m *RedisNotify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RedisNotify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RedisNotify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RedisNotify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedisNotify.Merge(m, src)
}
func (m *RedisNotify) XXX_Size() int {
	return m.Size()
}
func (m *RedisNotify) XXX_DiscardUnknown() {
	xxx_messageInfo_RedisNotify.DiscardUnknown(m)
}

var xxx_messageInfo_RedisNotify proto.InternalMessageInfo

func (m *RedisNotify) GetNewWorldMail() *RedisNotifyNewWorldMail {
	if m != nil {
		return m.NewWorldMail
	}
	return nil
}

func (m *RedisNotify) GetNewPlayerMail() *RedisNotifyNewPlayerMail {
	if m != nil {
		return m.NewPlayerMail
	}
	return nil
}

func init() {
	proto.RegisterEnum("AIStrategy", AIStrategy_name, AIStrategy_value)
	proto.RegisterEnum("CardEffect", CardEffect_name, CardEffect_value)
	proto.RegisterEnum("MatchMode", MatchMode_name, MatchMode_value)
	proto.RegisterEnum("LoginChannel", LoginChannel_name, LoginChannel_value)
	proto.RegisterEnum("MailState", MailState_name, MailState_value)
	proto.RegisterEnum("MailType", MailType_name, MailType_value)
	proto.RegisterEnum("PayChannel", PayChannel_name, PayChannel_value)
	proto.RegisterType((*CardInfo)(nil), "CardInfo")
	proto.RegisterType((*AreaInfo)(nil), "AreaInfo")
	proto.RegisterType((*ScoreInfo)(nil), "ScoreInfo")
	proto.RegisterType((*CardDetailInfo)(nil), "CardDetailInfo")
	proto.RegisterType((*Deck)(nil), "Deck")
	proto.RegisterType((*SeasonInfo)(nil), "SeasonInfo")
	proto.RegisterType((*RoomPlayerInfo)(nil), "RoomPlayerInfo")
	proto.RegisterMapType((map[int32]*AreaInfo)(nil), "RoomPlayerInfo.AreaInfoEntry")
	proto.RegisterType((*CardEvent)(nil), "CardEvent")
	proto.RegisterType((*RoundPlayerInfo)(nil), "RoundPlayerInfo")
	proto.RegisterType((*ItemInfo)(nil), "ItemInfo")
	proto.RegisterType((*MailBrief)(nil), "MailBrief")
	proto.RegisterType((*Mail)(nil), "Mail")
	proto.RegisterType((*RedisNotifyNewWorldMail)(nil), "RedisNotifyNewWorldMail")
	proto.RegisterType((*RedisNotifyNewPlayerMail)(nil), "RedisNotifyNewPlayerMail")
	proto.RegisterType((*RedisNotify)(nil), "RedisNotify")
}

func init() { proto.RegisterFile("proto/base/common.proto", fileDescriptor_da8d4bc57760a4b8) }

var fileDescriptor_da8d4bc57760a4b8 = []byte{
	// 1267 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x56, 0xcd, 0x6e, 0xdb, 0xc6,
	0x16, 0x36, 0x29, 0xc9, 0x91, 0x8e, 0x1c, 0x99, 0x77, 0xe2, 0x9b, 0x30, 0xc9, 0x8d, 0x92, 0x4b,
	0xe0, 0xde, 0x1a, 0x0a, 0xc2, 0x00, 0x2e, 0x0a, 0xb4, 0x4d, 0xd1, 0xc2, 0x91, 0x13, 0x57, 0x41,
	0x62, 0xb8, 0x23, 0x37, 0x05, 0xba, 0x09, 0x46, 0xe4, 0x48, 0x1e, 0x98, 0x9c, 0x11, 0xc8, 0x91,
	0x02, 0x3d, 0x42, 0x81, 0xa2, 0xe8, 0xba, 0x7d, 0x89, 0x3e, 0x46, 0x97, 0x59, 0x76, 0x59, 0x24,
	0xcb, 0xbe, 0x44, 0x71, 0x86, 0x43, 0x8a, 0x72, 0x91, 0xec, 0xe6, 0xfb, 0xe6, 0xf0, 0x9c, 0xef,
	0xfc, 0x0d, 0x08, 0x37, 0xe6, 0x99, 0xd2, 0xea, 0xe1, 0x84, 0xe5, 0xfc, 0x61, 0xa4, 0xd2, 0x54,
	0xc9, 0xd0, 0x30, 0xc1, 0x2f, 0x0e, 0xb4, 0x87, 0x2c, 0x8b, 0x47, 0x72, 0xaa, 0xc8, 0x75, 0xd8,
	0x8e, 0xf0, 0x1c, 0xfb, 0xce, 0x3d, 0x67, 0xbf, 0x45, 0x2d, 0x2a, 0xf9, 0xe1, 0xdc, 0x77, 0xd7,
	0xfc, 0x70, 0x4e, 0xfa, 0x00, 0x78, 0x7a, 0x32, 0x9d, 0xf2, 0x48, 0xfb, 0x0d, 0x73, 0x57, 0x63,
	0xc8, 0xff, 0xa1, 0xc7, 0xcc, 0x89, 0xc7, 0x43, 0xb5, 0x90, 0x3a, 0xf7, 0x9b, 0xc6, 0xe6, 0x12,
	0x8b, 0xfe, 0x59, 0xc6, 0xd9, 0x28, 0xf6, 0x5b, 0x85, 0xff, 0x02, 0x05, 0x14, 0xda, 0x87, 0x78,
	0xb2, 0xda, 0xac, 0x8d, 0x53, 0xb7, 0x21, 0x3d, 0x70, 0xa3, 0x52, 0x97, 0x1b, 0x55, 0x9a, 0x6c,
	0xbc, 0x9a, 0xa6, 0x82, 0x09, 0x52, 0xe8, 0x8c, 0x23, 0x95, 0x71, 0xe3, 0x74, 0x0f, 0x5a, 0x39,
	0x02, 0xeb, 0xb3, 0x00, 0xe4, 0x1e, 0x74, 0x63, 0xb5, 0x98, 0x24, 0xdc, 0x18, 0x5a, 0xdf, 0x75,
	0x8a, 0xec, 0xc3, 0x6e, 0xa4, 0x64, 0x2c, 0xb4, 0x50, 0xd2, 0x30, 0x18, 0xa9, 0xb1, 0xdf, 0xa2,
	0x97, 0xe9, 0x60, 0x0c, 0x3d, 0x2c, 0xef, 0x11, 0xd7, 0x4c, 0x24, 0x26, 0xe6, 0x0d, 0xb8, 0x82,
	0x72, 0x5e, 0x89, 0xcb, 0x55, 0xee, 0x81, 0x9b, 0x2c, 0xcb, 0x4c, 0x92, 0x25, 0xf1, 0xe1, 0x4a,
	0xb4, 0xc8, 0x46, 0x91, 0x92, 0x36, 0x8d, 0x12, 0x06, 0xbf, 0x39, 0xd0, 0x3c, 0xe2, 0xd1, 0x05,
	0x7e, 0x52, 0xb9, 0x71, 0x45, 0x4c, 0x6e, 0x41, 0x1b, 0x9d, 0x3d, 0x17, 0xb9, 0xf6, 0x5d, 0x23,
	0xa8, 0xc2, 0xe4, 0x3f, 0xd0, 0x89, 0x32, 0xce, 0xf4, 0x99, 0x48, 0xb9, 0x71, 0xd8, 0xa0, 0x6b,
	0x82, 0x10, 0x68, 0x4a, 0x96, 0x72, 0xd3, 0xa0, 0x0e, 0x35, 0x67, 0xf4, 0x36, 0x61, 0xd1, 0xc5,
	0xf8, 0x42, 0x48, 0xdb, 0x98, 0x0a, 0x63, 0x3b, 0xb4, 0xd0, 0x09, 0xcf, 0xfd, 0xed, 0x22, 0x89,
	0x02, 0x99, 0x36, 0x2d, 0x99, 0x66, 0x99, 0x7f, 0xc5, 0xb6, 0xc9, 0xa0, 0x40, 0x01, 0x8c, 0x39,
	0xcb, 0x95, 0x34, 0x35, 0xb8, 0x0d, 0x9d, 0xdc, 0xa0, 0x75, 0x15, 0xda, 0x05, 0x31, 0x8a, 0xd7,
	0x4d, 0x71, 0xeb, 0x4d, 0xd9, 0x83, 0xd6, 0x2c, 0x63, 0x31, 0xb7, 0xb5, 0x28, 0x00, 0xd6, 0x28,
	0x63, 0xf2, 0x42, 0xc8, 0x99, 0x1d, 0xad, 0x12, 0x06, 0xbf, 0x36, 0xa0, 0x47, 0x95, 0x4a, 0x4f,
	0x13, 0xb6, 0xe2, 0x99, 0x89, 0xea, 0x41, 0x63, 0x61, 0xe3, 0x75, 0x28, 0x1e, 0xab, 0xac, 0xdd,
	0x5a, 0xd6, 0x9f, 0xc0, 0x55, 0xac, 0xd9, 0x71, 0xa6, 0x16, 0x73, 0xfc, 0xcc, 0x74, 0xb6, 0x7b,
	0xb0, 0x1b, 0x6e, 0xf6, 0x91, 0x6e, 0x5a, 0x91, 0xdb, 0xe0, 0x32, 0x61, 0x44, 0xf4, 0x0e, 0xba,
	0xe1, 0xe1, 0x68, 0xac, 0x33, 0xa6, 0xf9, 0x6c, 0x45, 0x5d, 0x26, 0x30, 0xce, 0x39, 0x67, 0xe5,
	0x78, 0x9b, 0x33, 0xf9, 0x0c, 0xda, 0xcc, 0x0e, 0xb7, 0xbf, 0x6d, 0x42, 0xdc, 0x09, 0x37, 0x05,
	0x87, 0xe5, 0xf0, 0x3f, 0x91, 0x3a, 0x5b, 0xd1, 0xca, 0x9c, 0xfc, 0x17, 0xda, 0x31, 0x8f, 0x2e,
	0xcc, 0xa7, 0x58, 0xe6, 0xee, 0x41, 0x2b, 0xc4, 0x79, 0xa0, 0x15, 0x4d, 0xf6, 0xa1, 0x93, 0x97,
	0x63, 0xee, 0xb7, 0x8d, 0x0d, 0x84, 0xd5, 0xe0, 0xd3, 0xf5, 0x25, 0xb9, 0x0f, 0x90, 0x57, 0x9d,
	0xf1, 0x3b, 0xc6, 0xb4, 0x1b, 0xae, 0x9b, 0x45, 0x6b, 0xd7, 0xb7, 0x9e, 0xc2, 0xd5, 0x0d, 0x51,
	0x58, 0xd3, 0x0b, 0xbe, 0xb2, 0x3d, 0xc4, 0x23, 0xb9, 0x0b, 0xad, 0x25, 0x4b, 0x16, 0x45, 0x51,
	0xbb, 0x07, 0x9d, 0x2a, 0x0b, 0x5a, 0xf0, 0x9f, 0xbb, 0x9f, 0x3a, 0xc1, 0x29, 0x74, 0xb0, 0x9c,
	0x4f, 0x96, 0x5c, 0x6a, 0xf2, 0x11, 0xb4, 0xb9, 0x79, 0x10, 0xec, 0x72, 0x63, 0x01, 0x87, 0xd5,
	0x2b, 0x42, 0xab, 0x4b, 0x1c, 0x48, 0x8e, 0x5f, 0xbc, 0x64, 0x89, 0x1d, 0x8e, 0x0a, 0x07, 0x3f,
	0x38, 0xb0, 0x4b, 0xd5, 0x42, 0xc6, 0x1f, 0x6c, 0xf8, 0x1d, 0x68, 0x62, 0xdb, 0xcc, 0x72, 0xa0,
	0xb6, 0xf2, 0xe9, 0xa3, 0x86, 0xc6, 0xaa, 0x45, 0xa5, 0x2c, 0xdb, 0x77, 0x08, 0x2b, 0xa1, 0x74,
	0x7d, 0xf9, 0xc1, 0x76, 0x07, 0x5f, 0x42, 0x7b, 0xa4, 0x79, 0x5a, 0xae, 0xbb, 0xd0, 0x3c, 0xad,
	0xad, 0x3b, 0xc2, 0x51, 0x4c, 0x6e, 0x42, 0xdb, 0x5c, 0xc8, 0x45, 0x6a, 0x93, 0x31, 0x86, 0x27,
	0x8b, 0x34, 0xf8, 0xcb, 0x81, 0xce, 0x0b, 0x26, 0x92, 0xc7, 0x99, 0xe0, 0xd3, 0xda, 0x92, 0x37,
	0xcc, 0x92, 0xff, 0x0f, 0xda, 0x29, 0x13, 0xc9, 0xd9, 0x6a, 0x5e, 0xd4, 0xb8, 0x77, 0xd0, 0x09,
	0x5f, 0x58, 0x82, 0x56, 0x57, 0xe4, 0x1e, 0xb4, 0x72, 0xcd, 0x74, 0xb1, 0x30, 0xbd, 0x03, 0x30,
	0x36, 0x63, 0x64, 0x68, 0x71, 0x81, 0x2b, 0xa5, 0xcf, 0x79, 0xb5, 0xf4, 0x05, 0xc0, 0x59, 0xd5,
	0xf8, 0x44, 0xb4, 0x4c, 0x40, 0x73, 0xc6, 0x35, 0xe3, 0x32, 0x36, 0x2f, 0xc7, 0xb6, 0xa1, 0x4b,
	0x88, 0x3e, 0xa2, 0xe9, 0x6c, 0x14, 0xdb, 0x75, 0x2f, 0x00, 0xb9, 0x0f, 0x5d, 0xa6, 0x35, 0x8b,
	0xce, 0x53, 0x8e, 0xaf, 0x70, 0xdb, 0x56, 0xbb, 0x2c, 0x0a, 0xad, 0xdf, 0x06, 0x2f, 0xa1, 0x89,
	0xd2, 0x50, 0xf0, 0x04, 0x13, 0x36, 0xa9, 0x76, 0xad, 0x60, 0x53, 0x02, 0x5a, 0x5c, 0x60, 0x3f,
	0xd3, 0x7c, 0x66, 0xb7, 0x15, 0x8f, 0x38, 0x11, 0x39, 0x97, 0x31, 0xcf, 0x46, 0xb1, 0xc9, 0xb3,
	0x43, 0x2b, 0x1c, 0x3c, 0x80, 0x1b, 0x94, 0xc7, 0x22, 0x3f, 0x51, 0x5a, 0x4c, 0x57, 0x27, 0xfc,
	0xf5, 0x77, 0x2a, 0x4b, 0x62, 0x13, 0x8a, 0x40, 0x33, 0x66, 0x9a, 0xd9, 0xc9, 0x30, 0xe7, 0xe0,
	0x31, 0xf8, 0x9b, 0xe6, 0xc5, 0x20, 0x19, 0xfb, 0x7f, 0x0e, 0xd2, 0x1e, 0xb4, 0x52, 0x26, 0x46,
	0xb1, 0x11, 0xd3, 0xa0, 0x05, 0x08, 0x7e, 0x74, 0xa0, 0x5b, 0x73, 0x42, 0xbe, 0x80, 0x1d, 0x59,
	0x8b, 0x6b, 0x33, 0xf3, 0xc3, 0xf7, 0xe8, 0xa2, 0x1b, 0xd6, 0xe4, 0x2b, 0xb8, 0x2a, 0xeb, 0x32,
	0xec, 0x46, 0xdd, 0x0c, 0xdf, 0xa7, 0x93, 0x6e, 0xda, 0x0f, 0x7e, 0x72, 0x00, 0xd6, 0xa3, 0x49,
	0xae, 0xc1, 0xee, 0x1a, 0xbd, 0x3a, 0x51, 0x92, 0x7b, 0x5b, 0xe4, 0x2e, 0xdc, 0xae, 0x91, 0x43,
	0x95, 0xce, 0x13, 0xae, 0xf9, 0x31, 0x4b, 0xf9, 0xd3, 0x44, 0xbd, 0xf6, 0x1c, 0xf2, 0x6f, 0xf8,
	0xd7, 0xc6, 0x57, 0x59, 0xca, 0x12, 0xcf, 0xbd, 0xe4, 0xec, 0x6b, 0x96, 0xc5, 0x5e, 0x83, 0xf4,
	0xe1, 0x56, 0x8d, 0x7c, 0xb6, 0x90, 0x42, 0x65, 0x87, 0x79, 0x2e, 0x72, 0xcd, 0xa4, 0xf6, 0x9a,
	0x83, 0x53, 0x80, 0xf5, 0x62, 0xa3, 0x8b, 0x35, 0x2a, 0xf5, 0x5c, 0x07, 0x52, 0x23, 0x8f, 0x78,
	0xae, 0x55, 0xb6, 0x2a, 0x64, 0xd4, 0x78, 0xca, 0x97, 0x9c, 0x25, 0x5e, 0x73, 0xf0, 0x0c, 0x37,
	0x45, 0x47, 0xe7, 0x2f, 0x54, 0x8c, 0xa3, 0xdb, 0xab, 0x40, 0xe9, 0x6f, 0x0f, 0xbc, 0x3a, 0x67,
	0xd4, 0x3b, 0x18, 0x7a, 0xcd, 0x9e, 0xa9, 0xb9, 0x88, 0x3c, 0x77, 0xf0, 0x08, 0x76, 0x9e, 0xab,
	0x99, 0x90, 0xc3, 0x73, 0x26, 0x25, 0x4f, 0x30, 0x64, 0x1d, 0xd7, 0x3c, 0x6e, 0xd0, 0xdf, 0x28,
	0xe5, 0x39, 0x83, 0x47, 0xc5, 0xca, 0x9a, 0x05, 0x23, 0x3d, 0x00, 0x04, 0xdf, 0x4a, 0xca, 0x59,
	0xec, 0x6d, 0x91, 0x1d, 0x68, 0x9b, 0xfe, 0x20, 0x72, 0x88, 0x07, 0x3b, 0x05, 0x8a, 0xb8, 0x58,
	0xf2, 0xd8, 0x73, 0x07, 0x0f, 0x8a, 0x7b, 0xb3, 0xb7, 0xbb, 0xd0, 0xc5, 0xf3, 0x11, 0x9f, 0x0a,
	0xc9, 0xf1, 0x63, 0x6b, 0x7e, 0xc6, 0xd3, 0x79, 0xc2, 0x34, 0xf7, 0x9c, 0xc1, 0x04, 0xe0, 0x94,
	0xad, 0x4a, 0x99, 0xd7, 0x60, 0x77, 0x8d, 0x4a, 0x91, 0x04, 0x7a, 0x35, 0xd2, 0x48, 0x44, 0xe1,
	0x35, 0xee, 0x70, 0x3e, 0x4f, 0xb8, 0xe7, 0x62, 0x96, 0x35, 0xf6, 0x58, 0xa9, 0x59, 0xc2, 0xbd,
	0xc6, 0xe3, 0xd1, 0xef, 0x6f, 0xfb, 0xce, 0x9b, 0xb7, 0x7d, 0xe7, 0xcf, 0xb7, 0x7d, 0xe7, 0xe7,
	0x77, 0xfd, 0xad, 0x37, 0xef, 0xfa, 0x5b, 0x7f, 0xbc, 0xeb, 0x6f, 0xc1, 0xdd, 0x48, 0xa5, 0x61,
	0x7e, 0xbe, 0xc8, 0x99, 0x9c, 0x85, 0x3a, 0x9a, 0x15, 0x7f, 0x92, 0x91, 0x4a, 0xc2, 0x28, 0x11,
	0x5c, 0xea, 0x53, 0xe7, 0xfb, 0x9d, 0xe1, 0xf0, 0x78, 0xcc, 0xb3, 0x25, 0xcf, 0x1e, 0xce, 0x27,
	0x93, 0x6d, 0x63, 0xf0, 0xf1, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xf6, 0xf1, 0xda, 0x31, 0x85,
	0x0a, 0x00, 0x00,
}

func (m *CardInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CardInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AreaId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.AreaId))
		i--
		dAtA[i] = 0x28
	}
	if m.AffectedCounts != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.AffectedCounts))
		i--
		dAtA[i] = 0x20
	}
	if m.CardEffect != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.CardEffect))
		i--
		dAtA[i] = 0x18
	}
	if m.CardCp != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.CardCp))
		i--
		dAtA[i] = 0x10
	}
	if m.CardId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.CardId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AreaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AreaInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AreaInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CardCounts != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.CardCounts))
		i--
		dAtA[i] = 0x18
	}
	if m.Cp != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Cp))
		i--
		dAtA[i] = 0x10
	}
	if m.AreaId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.AreaId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ScoreInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScoreInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScoreInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConditionScores) > 0 {
		dAtA2 := make([]byte, len(m.ConditionScores)*10)
		var j1 int
		for _, num1 := range m.ConditionScores {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintCommon(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1a
	}
	if m.DoubleScore != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.DoubleScore))
		i--
		dAtA[i] = 0x10
	}
	if m.Score != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CardDetailInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardDetailInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CardDetailInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CurIcon != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.CurIcon))
		i--
		dAtA[i] = 0x18
	}
	if m.Lv != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Lv))
		i--
		dAtA[i] = 0x10
	}
	if m.CardId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.CardId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Deck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Avatar != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Avatar))
		i--
		dAtA[i] = 0x38
	}
	if m.Titles != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Titles))
		i--
		dAtA[i] = 0x30
	}
	if m.BackSkin != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.BackSkin))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.CreatTime != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.CreatTime))
		i--
		dAtA[i] = 0x18
	}
	if len(m.CardList) > 0 {
		dAtA4 := make([]byte, len(m.CardList)*10)
		var j3 int
		for _, num1 := range m.CardList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintCommon(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SeasonInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeasonInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SeasonInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ranking != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Ranking))
		i--
		dAtA[i] = 0x20
	}
	if m.Grade != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Grade))
		i--
		dAtA[i] = 0x18
	}
	if m.Score != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x10
	}
	if m.SeasonId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.SeasonId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoomPlayerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomPlayerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoomPlayerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SeasonInfo != nil {
		{
			size, err := m.SeasonInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.ScoreInfo != nil {
		{
			size, err := m.ScoreInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.DeckInfo != nil {
		{
			size, err := m.DeckInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AreaInfo) > 0 {
		for k := range m.AreaInfo {
			v := m.AreaInfo[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCommon(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintCommon(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintCommon(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Head != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Head))
		i--
		dAtA[i] = 0x28
	}
	if m.Ai != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Ai))
		i--
		dAtA[i] = 0x20
	}
	if len(m.CardGroupInfo) > 0 {
		for iNdEx := len(m.CardGroupInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CardGroupInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CardEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CardEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EventVal != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.EventVal))
		i--
		dAtA[i] = 0x10
	}
	if m.EffectId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.EffectId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoundPlayerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoundPlayerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoundPlayerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ai != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Ai))
		i--
		dAtA[i] = 0x20
	}
	if len(m.CardEvent) > 0 {
		for iNdEx := len(m.CardEvent) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CardEvent[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Card) > 0 {
		for iNdEx := len(m.Card) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Card[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ItemInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ItemNum != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.ItemNum))
		i--
		dAtA[i] = 0x10
	}
	if m.ItemId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.ItemId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MailBrief) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailBrief) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MailBrief) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attachments) > 0 {
		for iNdEx := len(m.Attachments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attachments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.CfgId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.CfgId))
		i--
		dAtA[i] = 0x38
	}
	if m.EndTime != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.EndTime))
		i--
		dAtA[i] = 0x30
	}
	if m.Time != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Theme) > 0 {
		i -= len(m.Theme)
		copy(dAtA[i:], m.Theme)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Theme)))
		i--
		dAtA[i] = 0x22
	}
	if m.State != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if m.MailType != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.MailType))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Mail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Mail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SenderId) > 0 {
		i -= len(m.SenderId)
		copy(dAtA[i:], m.SenderId)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.SenderId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Brief != nil {
		{
			size, err := m.Brief.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RedisNotifyNewWorldMail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedisNotifyNewWorldMail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RedisNotifyNewWorldMail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RedisNotifyNewPlayerMail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedisNotifyNewPlayerMail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RedisNotifyNewPlayerMail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaiId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.MaiId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RedisNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedisNotify) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RedisNotify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewPlayerMail != nil {
		{
			size, err := m.NewPlayerMail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NewWorldMail != nil {
		{
			size, err := m.NewWorldMail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCommon(dAtA []byte, offset int, v uint64) int {
	offset -= sovCommon(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CardInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CardId != 0 {
		n += 1 + sovCommon(uint64(m.CardId))
	}
	if m.CardCp != 0 {
		n += 1 + sovCommon(uint64(m.CardCp))
	}
	if m.CardEffect != 0 {
		n += 1 + sovCommon(uint64(m.CardEffect))
	}
	if m.AffectedCounts != 0 {
		n += 1 + sovCommon(uint64(m.AffectedCounts))
	}
	if m.AreaId != 0 {
		n += 1 + sovCommon(uint64(m.AreaId))
	}
	return n
}

func (m *AreaInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AreaId != 0 {
		n += 1 + sovCommon(uint64(m.AreaId))
	}
	if m.Cp != 0 {
		n += 1 + sovCommon(uint64(m.Cp))
	}
	if m.CardCounts != 0 {
		n += 1 + sovCommon(uint64(m.CardCounts))
	}
	return n
}

func (m *ScoreInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Score != 0 {
		n += 1 + sovCommon(uint64(m.Score))
	}
	if m.DoubleScore != 0 {
		n += 1 + sovCommon(uint64(m.DoubleScore))
	}
	if len(m.ConditionScores) > 0 {
		l = 0
		for _, e := range m.ConditionScores {
			l += sovCommon(uint64(e))
		}
		n += 1 + sovCommon(uint64(l)) + l
	}
	return n
}

func (m *CardDetailInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CardId != 0 {
		n += 1 + sovCommon(uint64(m.CardId))
	}
	if m.Lv != 0 {
		n += 1 + sovCommon(uint64(m.Lv))
	}
	if m.CurIcon != 0 {
		n += 1 + sovCommon(uint64(m.CurIcon))
	}
	return n
}

func (m *Deck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if len(m.CardList) > 0 {
		l = 0
		for _, e := range m.CardList {
			l += sovCommon(uint64(e))
		}
		n += 1 + sovCommon(uint64(l)) + l
	}
	if m.CreatTime != 0 {
		n += 1 + sovCommon(uint64(m.CreatTime))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.BackSkin != 0 {
		n += 1 + sovCommon(uint64(m.BackSkin))
	}
	if m.Titles != 0 {
		n += 1 + sovCommon(uint64(m.Titles))
	}
	if m.Avatar != 0 {
		n += 1 + sovCommon(uint64(m.Avatar))
	}
	return n
}

func (m *SeasonInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SeasonId != 0 {
		n += 1 + sovCommon(uint64(m.SeasonId))
	}
	if m.Score != 0 {
		n += 1 + sovCommon(uint64(m.Score))
	}
	if m.Grade != 0 {
		n += 1 + sovCommon(uint64(m.Grade))
	}
	if m.Ranking != 0 {
		n += 1 + sovCommon(uint64(m.Ranking))
	}
	return n
}

func (m *RoomPlayerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.CardGroupInfo) > 0 {
		for _, e := range m.CardGroupInfo {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.Ai != 0 {
		n += 1 + sovCommon(uint64(m.Ai))
	}
	if m.Head != 0 {
		n += 1 + sovCommon(uint64(m.Head))
	}
	if len(m.AreaInfo) > 0 {
		for k, v := range m.AreaInfo {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.DeckInfo != nil {
		l = m.DeckInfo.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.ScoreInfo != nil {
		l = m.ScoreInfo.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.SeasonInfo != nil {
		l = m.SeasonInfo.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *CardEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EffectId != 0 {
		n += 1 + sovCommon(uint64(m.EffectId))
	}
	if m.EventVal != 0 {
		n += 1 + sovCommon(uint64(m.EventVal))
	}
	return n
}

func (m *RoundPlayerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.Card) > 0 {
		for _, e := range m.Card {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.CardEvent) > 0 {
		for _, e := range m.CardEvent {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.Ai != 0 {
		n += 1 + sovCommon(uint64(m.Ai))
	}
	return n
}

func (m *ItemInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovCommon(uint64(m.ItemId))
	}
	if m.ItemNum != 0 {
		n += 1 + sovCommon(uint64(m.ItemNum))
	}
	return n
}

func (m *MailBrief) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.MailType != 0 {
		n += 1 + sovCommon(uint64(m.MailType))
	}
	if m.State != 0 {
		n += 1 + sovCommon(uint64(m.State))
	}
	l = len(m.Theme)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovCommon(uint64(m.Time))
	}
	if m.EndTime != 0 {
		n += 1 + sovCommon(uint64(m.EndTime))
	}
	if m.CfgId != 0 {
		n += 1 + sovCommon(uint64(m.CfgId))
	}
	if len(m.Attachments) > 0 {
		for _, e := range m.Attachments {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *Mail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Brief != nil {
		l = m.Brief.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.SenderId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *RedisNotifyNewWorldMail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *RedisNotifyNewPlayerMail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.MaiId != 0 {
		n += 1 + sovCommon(uint64(m.MaiId))
	}
	return n
}

func (m *RedisNotify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewWorldMail != nil {
		l = m.NewWorldMail.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.NewPlayerMail != nil {
		l = m.NewPlayerMail.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func sovCommon(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCommon(x uint64) (n int) {
	return sovCommon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CardInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardId", wireType)
			}
			m.CardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardCp", wireType)
			}
			m.CardCp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardCp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardEffect", wireType)
			}
			m.CardEffect = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardEffect |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffectedCounts", wireType)
			}
			m.AffectedCounts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AffectedCounts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaId", wireType)
			}
			m.AreaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AreaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AreaInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AreaInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaId", wireType)
			}
			m.AreaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cp", wireType)
			}
			m.Cp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardCounts", wireType)
			}
			m.CardCounts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardCounts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScoreInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScoreInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScoreInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleScore", wireType)
			}
			m.DoubleScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DoubleScore |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ConditionScores = append(m.ConditionScores, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCommon
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ConditionScores) == 0 {
					m.ConditionScores = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ConditionScores = append(m.ConditionScores, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionScores", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardDetailInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardDetailInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardDetailInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardId", wireType)
			}
			m.CardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurIcon", wireType)
			}
			m.CurIcon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurIcon |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CardList = append(m.CardList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCommon
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CardList) == 0 {
					m.CardList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CardList = append(m.CardList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CardList", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatTime", wireType)
			}
			m.CreatTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackSkin", wireType)
			}
			m.BackSkin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackSkin |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Titles", wireType)
			}
			m.Titles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Titles |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			m.Avatar = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Avatar |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeasonInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeasonInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeasonInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonId", wireType)
			}
			m.SeasonId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeasonId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grade", wireType)
			}
			m.Grade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Grade |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranking", wireType)
			}
			m.Ranking = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ranking |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomPlayerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomPlayerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomPlayerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardGroupInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CardGroupInfo = append(m.CardGroupInfo, &CardDetailInfo{})
			if err := m.CardGroupInfo[len(m.CardGroupInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ai", wireType)
			}
			m.Ai = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ai |= AIStrategy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			m.Head = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Head |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AreaInfo == nil {
				m.AreaInfo = make(map[int32]*AreaInfo)
			}
			var mapkey int32
			var mapvalue *AreaInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AreaInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AreaInfo[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeckInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeckInfo == nil {
				m.DeckInfo = &Deck{}
			}
			if err := m.DeckInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScoreInfo == nil {
				m.ScoreInfo = &ScoreInfo{}
			}
			if err := m.ScoreInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SeasonInfo == nil {
				m.SeasonInfo = &SeasonInfo{}
			}
			if err := m.SeasonInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectId", wireType)
			}
			m.EffectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EffectId |= CardEffect(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventVal", wireType)
			}
			m.EventVal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventVal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoundPlayerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoundPlayerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoundPlayerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Card = append(m.Card, &CardInfo{})
			if err := m.Card[len(m.Card)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CardEvent = append(m.CardEvent, &CardEvent{})
			if err := m.CardEvent[len(m.CardEvent)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ai", wireType)
			}
			m.Ai = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ai |= AIStrategy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemNum", wireType)
			}
			m.ItemNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailBrief) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailBrief: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailBrief: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailType", wireType)
			}
			m.MailType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MailType |= MailType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= MailState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Theme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Theme = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfgId", wireType)
			}
			m.CfgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CfgId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attachments = append(m.Attachments, &ItemInfo{})
			if err := m.Attachments[len(m.Attachments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Brief", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Brief == nil {
				m.Brief = &MailBrief{}
			}
			if err := m.Brief.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedisNotifyNewWorldMail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedisNotifyNewWorldMail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedisNotifyNewWorldMail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedisNotifyNewPlayerMail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedisNotifyNewPlayerMail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedisNotifyNewPlayerMail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaiId", wireType)
			}
			m.MaiId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaiId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedisNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedisNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedisNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewWorldMail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewWorldMail == nil {
				m.NewWorldMail = &RedisNotifyNewWorldMail{}
			}
			if err := m.NewWorldMail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPlayerMail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewPlayerMail == nil {
				m.NewPlayerMail = &RedisNotifyNewPlayerMail{}
			}
			if err := m.NewPlayerMail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCommon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCommon
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCommon
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCommon
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCommon        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCommon          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCommon = fmt.Errorf("proto: unexpected end of group")
)
