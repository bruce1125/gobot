// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/base/room.proto

package pb

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// 注册房间服务器
type U2RRegisterRoom struct {
	Ip       string `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	Port     int32  `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	MatchNum int32  `protobuf:"varint,3,opt,name=matchNum,proto3" json:"matchNum,omitempty"`
}

func (m *U2RRegisterRoom) Reset()         { *m = U2RRegisterRoom{} }
func (m *U2RRegisterRoom) String() string { return proto.CompactTextString(m) }
func (*U2RRegisterRoom) ProtoMessage()    {}
func (*U2RRegisterRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea35affbc550ab8f, []int{0}
}
func (m *U2RRegisterRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *U2RRegisterRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_U2RRegisterRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *U2RRegisterRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_U2RRegisterRoom.Merge(m, src)
}
func (m *U2RRegisterRoom) XXX_Size() int {
	return m.Size()
}
func (m *U2RRegisterRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_U2RRegisterRoom.DiscardUnknown(m)
}

var xxx_messageInfo_U2RRegisterRoom proto.InternalMessageInfo

func (m *U2RRegisterRoom) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *U2RRegisterRoom) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *U2RRegisterRoom) GetMatchNum() int32 {
	if m != nil {
		return m.MatchNum
	}
	return 0
}

type R2URegisterRoom struct {
}

func (m *R2URegisterRoom) Reset()         { *m = R2URegisterRoom{} }
func (m *R2URegisterRoom) String() string { return proto.CompactTextString(m) }
func (*R2URegisterRoom) ProtoMessage()    {}
func (*R2URegisterRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea35affbc550ab8f, []int{1}
}
func (m *R2URegisterRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *R2URegisterRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_R2URegisterRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *R2URegisterRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_R2URegisterRoom.Merge(m, src)
}
func (m *R2URegisterRoom) XXX_Size() int {
	return m.Size()
}
func (m *R2URegisterRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_R2URegisterRoom.DiscardUnknown(m)
}

var xxx_messageInfo_R2URegisterRoom proto.InternalMessageInfo

// 开启对局房间
type M2RCreateNewMatch struct {
	MatchId string            `protobuf:"bytes,1,opt,name=matchId,proto3" json:"matchId,omitempty"`
	Players []*RoomPlayerInfo `protobuf:"bytes,2,rep,name=players,proto3" json:"players,omitempty"`
}

func (m *M2RCreateNewMatch) Reset()         { *m = M2RCreateNewMatch{} }
func (m *M2RCreateNewMatch) String() string { return proto.CompactTextString(m) }
func (*M2RCreateNewMatch) ProtoMessage()    {}
func (*M2RCreateNewMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea35affbc550ab8f, []int{2}
}
func (m *M2RCreateNewMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *M2RCreateNewMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_M2RCreateNewMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *M2RCreateNewMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_M2RCreateNewMatch.Merge(m, src)
}
func (m *M2RCreateNewMatch) XXX_Size() int {
	return m.Size()
}
func (m *M2RCreateNewMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_M2RCreateNewMatch.DiscardUnknown(m)
}

var xxx_messageInfo_M2RCreateNewMatch proto.InternalMessageInfo

func (m *M2RCreateNewMatch) GetMatchId() string {
	if m != nil {
		return m.MatchId
	}
	return ""
}

func (m *M2RCreateNewMatch) GetPlayers() []*RoomPlayerInfo {
	if m != nil {
		return m.Players
	}
	return nil
}

type R2MCreateNewMatch struct {
}

func (m *R2MCreateNewMatch) Reset()         { *m = R2MCreateNewMatch{} }
func (m *R2MCreateNewMatch) String() string { return proto.CompactTextString(m) }
func (*R2MCreateNewMatch) ProtoMessage()    {}
func (*R2MCreateNewMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea35affbc550ab8f, []int{3}
}
func (m *R2MCreateNewMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *R2MCreateNewMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_R2MCreateNewMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *R2MCreateNewMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_R2MCreateNewMatch.Merge(m, src)
}
func (m *R2MCreateNewMatch) XXX_Size() int {
	return m.Size()
}
func (m *R2MCreateNewMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_R2MCreateNewMatch.DiscardUnknown(m)
}

var xxx_messageInfo_R2MCreateNewMatch proto.InternalMessageInfo

// 通知房间服务器开启对局
type R2UCreateNewMatch struct {
	MatchId string            `protobuf:"bytes,1,opt,name=matchId,proto3" json:"matchId,omitempty"`
	Players []*RoomPlayerInfo `protobuf:"bytes,2,rep,name=players,proto3" json:"players,omitempty"`
}

func (m *R2UCreateNewMatch) Reset()         { *m = R2UCreateNewMatch{} }
func (m *R2UCreateNewMatch) String() string { return proto.CompactTextString(m) }
func (*R2UCreateNewMatch) ProtoMessage()    {}
func (*R2UCreateNewMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea35affbc550ab8f, []int{4}
}
func (m *R2UCreateNewMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *R2UCreateNewMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_R2UCreateNewMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *R2UCreateNewMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_R2UCreateNewMatch.Merge(m, src)
}
func (m *R2UCreateNewMatch) XXX_Size() int {
	return m.Size()
}
func (m *R2UCreateNewMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_R2UCreateNewMatch.DiscardUnknown(m)
}

var xxx_messageInfo_R2UCreateNewMatch proto.InternalMessageInfo

func (m *R2UCreateNewMatch) GetMatchId() string {
	if m != nil {
		return m.MatchId
	}
	return ""
}

func (m *R2UCreateNewMatch) GetPlayers() []*RoomPlayerInfo {
	if m != nil {
		return m.Players
	}
	return nil
}

// 告诉房间管理服务器对局已开启
type U2RCreateNewMatch struct {
	MatchId string            `protobuf:"bytes,1,opt,name=matchId,proto3" json:"matchId,omitempty"`
	Players []*RoomPlayerInfo `protobuf:"bytes,2,rep,name=players,proto3" json:"players,omitempty"`
}

func (m *U2RCreateNewMatch) Reset()         { *m = U2RCreateNewMatch{} }
func (m *U2RCreateNewMatch) String() string { return proto.CompactTextString(m) }
func (*U2RCreateNewMatch) ProtoMessage()    {}
func (*U2RCreateNewMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea35affbc550ab8f, []int{5}
}
func (m *U2RCreateNewMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *U2RCreateNewMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_U2RCreateNewMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *U2RCreateNewMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_U2RCreateNewMatch.Merge(m, src)
}
func (m *U2RCreateNewMatch) XXX_Size() int {
	return m.Size()
}
func (m *U2RCreateNewMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_U2RCreateNewMatch.DiscardUnknown(m)
}

var xxx_messageInfo_U2RCreateNewMatch proto.InternalMessageInfo

func (m *U2RCreateNewMatch) GetMatchId() string {
	if m != nil {
		return m.MatchId
	}
	return ""
}

func (m *U2RCreateNewMatch) GetPlayers() []*RoomPlayerInfo {
	if m != nil {
		return m.Players
	}
	return nil
}

// 对局结束
type U2RMatchGameOver struct {
	MatchId   string                     `protobuf:"bytes,1,opt,name=matchId,proto3" json:"matchId,omitempty"`
	WinnerUid string                     `protobuf:"bytes,2,opt,name=winnerUid,proto3" json:"winnerUid,omitempty"`
	Players   map[string]*RoomPlayerInfo `protobuf:"bytes,3,rep,name=players,proto3" json:"players,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *U2RMatchGameOver) Reset()         { *m = U2RMatchGameOver{} }
func (m *U2RMatchGameOver) String() string { return proto.CompactTextString(m) }
func (*U2RMatchGameOver) ProtoMessage()    {}
func (*U2RMatchGameOver) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea35affbc550ab8f, []int{6}
}
func (m *U2RMatchGameOver) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *U2RMatchGameOver) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_U2RMatchGameOver.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *U2RMatchGameOver) XXX_Merge(src proto.Message) {
	xxx_messageInfo_U2RMatchGameOver.Merge(m, src)
}
func (m *U2RMatchGameOver) XXX_Size() int {
	return m.Size()
}
func (m *U2RMatchGameOver) XXX_DiscardUnknown() {
	xxx_messageInfo_U2RMatchGameOver.DiscardUnknown(m)
}

var xxx_messageInfo_U2RMatchGameOver proto.InternalMessageInfo

func (m *U2RMatchGameOver) GetMatchId() string {
	if m != nil {
		return m.MatchId
	}
	return ""
}

func (m *U2RMatchGameOver) GetWinnerUid() string {
	if m != nil {
		return m.WinnerUid
	}
	return ""
}

func (m *U2RMatchGameOver) GetPlayers() map[string]*RoomPlayerInfo {
	if m != nil {
		return m.Players
	}
	return nil
}

type R2UMatchGameOver struct {
}

func (m *R2UMatchGameOver) Reset()         { *m = R2UMatchGameOver{} }
func (m *R2UMatchGameOver) String() string { return proto.CompactTextString(m) }
func (*R2UMatchGameOver) ProtoMessage()    {}
func (*R2UMatchGameOver) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea35affbc550ab8f, []int{7}
}
func (m *R2UMatchGameOver) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *R2UMatchGameOver) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_R2UMatchGameOver.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *R2UMatchGameOver) XXX_Merge(src proto.Message) {
	xxx_messageInfo_R2UMatchGameOver.Merge(m, src)
}
func (m *R2UMatchGameOver) XXX_Size() int {
	return m.Size()
}
func (m *R2UMatchGameOver) XXX_DiscardUnknown() {
	xxx_messageInfo_R2UMatchGameOver.DiscardUnknown(m)
}

var xxx_messageInfo_R2UMatchGameOver proto.InternalMessageInfo

// 开始匹配
type L2MApplyMatch struct {
	CardGroupInfo string `protobuf:"bytes,1,opt,name=cardGroupInfo,proto3" json:"cardGroupInfo,omitempty"`
}

func (m *L2MApplyMatch) Reset()         { *m = L2MApplyMatch{} }
func (m *L2MApplyMatch) String() string { return proto.CompactTextString(m) }
func (*L2MApplyMatch) ProtoMessage()    {}
func (*L2MApplyMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea35affbc550ab8f, []int{8}
}
func (m *L2MApplyMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L2MApplyMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L2MApplyMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L2MApplyMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L2MApplyMatch.Merge(m, src)
}
func (m *L2MApplyMatch) XXX_Size() int {
	return m.Size()
}
func (m *L2MApplyMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_L2MApplyMatch.DiscardUnknown(m)
}

var xxx_messageInfo_L2MApplyMatch proto.InternalMessageInfo

func (m *L2MApplyMatch) GetCardGroupInfo() string {
	if m != nil {
		return m.CardGroupInfo
	}
	return ""
}

// 回合结束
type U2RGameRoundOver struct {
	MatchId string                      `protobuf:"bytes,1,opt,name=matchId,proto3" json:"matchId,omitempty"`
	RoundId int32                       `protobuf:"varint,2,opt,name=roundId,proto3" json:"roundId,omitempty"`
	Players map[string]*RoundPlayerInfo `protobuf:"bytes,3,rep,name=players,proto3" json:"players,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *U2RGameRoundOver) Reset()         { *m = U2RGameRoundOver{} }
func (m *U2RGameRoundOver) String() string { return proto.CompactTextString(m) }
func (*U2RGameRoundOver) ProtoMessage()    {}
func (*U2RGameRoundOver) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea35affbc550ab8f, []int{9}
}
func (m *U2RGameRoundOver) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *U2RGameRoundOver) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_U2RGameRoundOver.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *U2RGameRoundOver) XXX_Merge(src proto.Message) {
	xxx_messageInfo_U2RGameRoundOver.Merge(m, src)
}
func (m *U2RGameRoundOver) XXX_Size() int {
	return m.Size()
}
func (m *U2RGameRoundOver) XXX_DiscardUnknown() {
	xxx_messageInfo_U2RGameRoundOver.DiscardUnknown(m)
}

var xxx_messageInfo_U2RGameRoundOver proto.InternalMessageInfo

func (m *U2RGameRoundOver) GetMatchId() string {
	if m != nil {
		return m.MatchId
	}
	return ""
}

func (m *U2RGameRoundOver) GetRoundId() int32 {
	if m != nil {
		return m.RoundId
	}
	return 0
}

func (m *U2RGameRoundOver) GetPlayers() map[string]*RoundPlayerInfo {
	if m != nil {
		return m.Players
	}
	return nil
}

type R2UGameRoundOver struct {
}

func (m *R2UGameRoundOver) Reset()         { *m = R2UGameRoundOver{} }
func (m *R2UGameRoundOver) String() string { return proto.CompactTextString(m) }
func (*R2UGameRoundOver) ProtoMessage()    {}
func (*R2UGameRoundOver) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea35affbc550ab8f, []int{10}
}
func (m *R2UGameRoundOver) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *R2UGameRoundOver) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_R2UGameRoundOver.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *R2UGameRoundOver) XXX_Merge(src proto.Message) {
	xxx_messageInfo_R2UGameRoundOver.Merge(m, src)
}
func (m *R2UGameRoundOver) XXX_Size() int {
	return m.Size()
}
func (m *R2UGameRoundOver) XXX_DiscardUnknown() {
	xxx_messageInfo_R2UGameRoundOver.DiscardUnknown(m)
}

var xxx_messageInfo_R2UGameRoundOver proto.InternalMessageInfo

func init() {
	proto.RegisterType((*U2RRegisterRoom)(nil), "U2RRegisterRoom")
	proto.RegisterType((*R2URegisterRoom)(nil), "R2URegisterRoom")
	proto.RegisterType((*M2RCreateNewMatch)(nil), "M2RCreateNewMatch")
	proto.RegisterType((*R2MCreateNewMatch)(nil), "R2MCreateNewMatch")
	proto.RegisterType((*R2UCreateNewMatch)(nil), "R2UCreateNewMatch")
	proto.RegisterType((*U2RCreateNewMatch)(nil), "U2RCreateNewMatch")
	proto.RegisterType((*U2RMatchGameOver)(nil), "U2RMatchGameOver")
	proto.RegisterMapType((map[string]*RoomPlayerInfo)(nil), "U2RMatchGameOver.PlayersEntry")
	proto.RegisterType((*R2UMatchGameOver)(nil), "R2UMatchGameOver")
	proto.RegisterType((*L2MApplyMatch)(nil), "L2MApplyMatch")
	proto.RegisterType((*U2RGameRoundOver)(nil), "U2RGameRoundOver")
	proto.RegisterMapType((map[string]*RoundPlayerInfo)(nil), "U2RGameRoundOver.PlayersEntry")
	proto.RegisterType((*R2UGameRoundOver)(nil), "R2UGameRoundOver")
}

func init() { proto.RegisterFile("proto/base/room.proto", fileDescriptor_ea35affbc550ab8f) }

var fileDescriptor_ea35affbc550ab8f = []byte{
	// 467 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x93, 0x41, 0x6f, 0xd3, 0x30,
	0x14, 0xc7, 0xeb, 0x94, 0x51, 0xfa, 0xd8, 0x68, 0x6b, 0x84, 0x88, 0x2a, 0x14, 0xaa, 0x08, 0x50,
	0xb9, 0xa4, 0x92, 0x11, 0xd2, 0xc4, 0x0d, 0x2a, 0x54, 0x55, 0xac, 0x63, 0x18, 0x45, 0x9a, 0xb8,
	0xa5, 0x89, 0xe9, 0x22, 0x12, 0xdb, 0x72, 0x9c, 0x4e, 0xfd, 0x16, 0x7c, 0x2c, 0x4e, 0x68, 0xdc,
	0x38, 0xa2, 0xf6, 0x8b, 0xa0, 0x38, 0xed, 0xd6, 0x20, 0xb6, 0x9d, 0x7a, 0xf3, 0x7b, 0xcf, 0xf9,
	0xfd, 0xec, 0x7f, 0x12, 0x78, 0x24, 0x95, 0xd0, 0x62, 0x30, 0x0d, 0x32, 0x36, 0x50, 0x42, 0xa4,
	0x9e, 0xa9, 0xbb, 0x8f, 0xb7, 0xda, 0xa1, 0x48, 0x53, 0xc1, 0xcb, 0x81, 0xfb, 0x09, 0x5a, 0x3e,
	0xa1, 0x94, 0xcd, 0xe2, 0x4c, 0x33, 0x45, 0x85, 0x48, 0xf1, 0x03, 0xb0, 0x62, 0x69, 0xa3, 0x1e,
	0xea, 0x37, 0xa9, 0x15, 0x4b, 0x8c, 0xe1, 0x8e, 0x14, 0x4a, 0xdb, 0x56, 0x0f, 0xf5, 0xf7, 0xa8,
	0x59, 0xe3, 0x2e, 0xdc, 0x4b, 0x03, 0x1d, 0x9e, 0x1d, 0xe7, 0xa9, 0x5d, 0x37, 0xfd, 0xcb, 0xda,
	0xed, 0x40, 0x8b, 0x12, 0x7f, 0x1b, 0xe9, 0x9e, 0x42, 0x67, 0x42, 0xe8, 0x50, 0xb1, 0x40, 0xb3,
	0x63, 0x76, 0x3e, 0x29, 0xb6, 0x62, 0x1b, 0x1a, 0xe6, 0x99, 0x71, 0xb4, 0x96, 0x6d, 0x4a, 0xfc,
	0x12, 0x1a, 0x32, 0x09, 0x16, 0x4c, 0x65, 0xb6, 0xd5, 0xab, 0xf7, 0xef, 0x93, 0x96, 0x57, 0x60,
	0x4e, 0x4c, 0x6f, 0xcc, 0xbf, 0x0a, 0xba, 0x99, 0xbb, 0x0f, 0xa1, 0x43, 0xc9, 0xa4, 0x4a, 0x2e,
	0x74, 0x94, 0xf8, 0xbb, 0xd0, 0x9d, 0x42, 0xc7, 0xdf, 0xcd, 0x45, 0x7e, 0x21, 0x68, 0xfb, 0x84,
	0x1a, 0xe2, 0x28, 0x48, 0xd9, 0xc7, 0x39, 0x53, 0x37, 0x90, 0x9f, 0x40, 0xf3, 0x3c, 0xe6, 0x9c,
	0x29, 0x3f, 0x8e, 0xcc, 0x9b, 0x69, 0xd2, 0xab, 0x06, 0x3e, 0xbc, 0xf2, 0xd6, 0x8d, 0xd7, 0xf1,
	0xfe, 0x65, 0x7b, 0xe5, 0x21, 0xb2, 0xf7, 0x5c, 0xab, 0xc5, 0xe5, 0x31, 0xba, 0x1f, 0x60, 0x7f,
	0x7b, 0x80, 0xdb, 0x50, 0xff, 0xc6, 0x16, 0x6b, 0x7b, 0xb1, 0xc4, 0xcf, 0x61, 0x6f, 0x1e, 0x24,
	0x39, 0x33, 0xd6, 0xff, 0xdc, 0xa8, 0x9c, 0xbe, 0xb1, 0x0e, 0x91, 0x8b, 0xa1, 0x4d, 0x89, 0x5f,
	0xd1, 0xba, 0xaf, 0xe1, 0xe0, 0x88, 0x4c, 0xde, 0x4a, 0x99, 0x2c, 0xca, 0xf4, 0x9e, 0xc1, 0x41,
	0x18, 0xa8, 0x68, 0xa4, 0x44, 0x2e, 0x0b, 0xc0, 0xda, 0x55, 0x6d, 0xba, 0x3f, 0xcb, 0x78, 0x0a,
	0x0c, 0x15, 0x39, 0x8f, 0x6e, 0x89, 0xc7, 0x86, 0x86, 0x2a, 0xb6, 0x8d, 0xa3, 0xf5, 0x67, 0xbb,
	0x29, 0xaf, 0x89, 0xa6, 0xc2, 0xbd, 0x26, 0x9a, 0xa3, 0x5b, 0xa3, 0x79, 0x51, 0x8d, 0xa6, 0xed,
	0x19, 0xe4, 0x4d, 0xd9, 0x54, 0xbc, 0xef, 0xc6, 0x3f, 0x96, 0x0e, 0xba, 0x58, 0x3a, 0xe8, 0xcf,
	0xd2, 0x41, 0xdf, 0x57, 0x4e, 0xed, 0x62, 0xe5, 0xd4, 0x7e, 0xaf, 0x9c, 0x1a, 0x3c, 0x0d, 0x45,
	0xea, 0x65, 0x67, 0x79, 0x16, 0xf0, 0x99, 0xa7, 0xc3, 0x59, 0xf9, 0xf7, 0x86, 0x22, 0xf1, 0xc2,
	0x24, 0x66, 0x5c, 0x9f, 0xa0, 0x2f, 0xfb, 0xc3, 0xe1, 0xe8, 0x33, 0x53, 0x73, 0xa6, 0x06, 0x72,
	0x3a, 0xbd, 0x6b, 0x36, 0xbc, 0xfa, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x25, 0x51, 0x89, 0xeb, 0x10,
	0x04, 0x00, 0x00,
}

func (m *U2RRegisterRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *U2RRegisterRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *U2RRegisterRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MatchNum != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.MatchNum))
		i--
		dAtA[i] = 0x18
	}
	if m.Port != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintRoom(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *R2URegisterRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *R2URegisterRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *R2URegisterRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *M2RCreateNewMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *M2RCreateNewMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *M2RCreateNewMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Players) > 0 {
		for iNdEx := len(m.Players) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Players[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoom(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MatchId) > 0 {
		i -= len(m.MatchId)
		copy(dAtA[i:], m.MatchId)
		i = encodeVarintRoom(dAtA, i, uint64(len(m.MatchId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *R2MCreateNewMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *R2MCreateNewMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *R2MCreateNewMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *R2UCreateNewMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *R2UCreateNewMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *R2UCreateNewMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Players) > 0 {
		for iNdEx := len(m.Players) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Players[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoom(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MatchId) > 0 {
		i -= len(m.MatchId)
		copy(dAtA[i:], m.MatchId)
		i = encodeVarintRoom(dAtA, i, uint64(len(m.MatchId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *U2RCreateNewMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *U2RCreateNewMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *U2RCreateNewMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Players) > 0 {
		for iNdEx := len(m.Players) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Players[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoom(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MatchId) > 0 {
		i -= len(m.MatchId)
		copy(dAtA[i:], m.MatchId)
		i = encodeVarintRoom(dAtA, i, uint64(len(m.MatchId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *U2RMatchGameOver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *U2RMatchGameOver) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *U2RMatchGameOver) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Players) > 0 {
		for k := range m.Players {
			v := m.Players[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintRoom(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintRoom(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintRoom(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.WinnerUid) > 0 {
		i -= len(m.WinnerUid)
		copy(dAtA[i:], m.WinnerUid)
		i = encodeVarintRoom(dAtA, i, uint64(len(m.WinnerUid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MatchId) > 0 {
		i -= len(m.MatchId)
		copy(dAtA[i:], m.MatchId)
		i = encodeVarintRoom(dAtA, i, uint64(len(m.MatchId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *R2UMatchGameOver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *R2UMatchGameOver) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *R2UMatchGameOver) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *L2MApplyMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2MApplyMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L2MApplyMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CardGroupInfo) > 0 {
		i -= len(m.CardGroupInfo)
		copy(dAtA[i:], m.CardGroupInfo)
		i = encodeVarintRoom(dAtA, i, uint64(len(m.CardGroupInfo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *U2RGameRoundOver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *U2RGameRoundOver) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *U2RGameRoundOver) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Players) > 0 {
		for k := range m.Players {
			v := m.Players[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintRoom(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintRoom(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintRoom(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.RoundId != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.RoundId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MatchId) > 0 {
		i -= len(m.MatchId)
		copy(dAtA[i:], m.MatchId)
		i = encodeVarintRoom(dAtA, i, uint64(len(m.MatchId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *R2UGameRoundOver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *R2UGameRoundOver) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *R2UGameRoundOver) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintRoom(dAtA []byte, offset int, v uint64) int {
	offset -= sovRoom(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *U2RRegisterRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovRoom(uint64(m.Port))
	}
	if m.MatchNum != 0 {
		n += 1 + sovRoom(uint64(m.MatchNum))
	}
	return n
}

func (m *R2URegisterRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *M2RCreateNewMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MatchId)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovRoom(uint64(l))
		}
	}
	return n
}

func (m *R2MCreateNewMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *R2UCreateNewMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MatchId)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovRoom(uint64(l))
		}
	}
	return n
}

func (m *U2RCreateNewMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MatchId)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovRoom(uint64(l))
		}
	}
	return n
}

func (m *U2RMatchGameOver) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MatchId)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	l = len(m.WinnerUid)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	if len(m.Players) > 0 {
		for k, v := range m.Players {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRoom(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovRoom(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovRoom(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *R2UMatchGameOver) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *L2MApplyMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CardGroupInfo)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	return n
}

func (m *U2RGameRoundOver) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MatchId)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	if m.RoundId != 0 {
		n += 1 + sovRoom(uint64(m.RoundId))
	}
	if len(m.Players) > 0 {
		for k, v := range m.Players {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRoom(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovRoom(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovRoom(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *R2UGameRoundOver) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovRoom(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRoom(x uint64) (n int) {
	return sovRoom(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *U2RRegisterRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: U2RRegisterRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: U2RRegisterRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoom
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchNum", wireType)
			}
			m.MatchNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *R2URegisterRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: R2URegisterRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: R2URegisterRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *M2RCreateNewMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: M2RCreateNewMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: M2RCreateNewMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoom
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoom
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &RoomPlayerInfo{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *R2MCreateNewMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: R2MCreateNewMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: R2MCreateNewMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *R2UCreateNewMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: R2UCreateNewMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: R2UCreateNewMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoom
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoom
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &RoomPlayerInfo{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *U2RCreateNewMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: U2RCreateNewMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: U2RCreateNewMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoom
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoom
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &RoomPlayerInfo{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *U2RMatchGameOver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: U2RMatchGameOver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: U2RMatchGameOver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoom
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinnerUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoom
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WinnerUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoom
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Players == nil {
				m.Players = make(map[string]*RoomPlayerInfo)
			}
			var mapkey string
			var mapvalue *RoomPlayerInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoom
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoom
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRoom
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthRoom
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoom
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRoom
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthRoom
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RoomPlayerInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoom(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthRoom
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Players[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *R2UMatchGameOver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: R2UMatchGameOver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: R2UMatchGameOver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2MApplyMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2MApplyMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2MApplyMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardGroupInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoom
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CardGroupInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *U2RGameRoundOver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: U2RGameRoundOver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: U2RGameRoundOver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoom
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundId", wireType)
			}
			m.RoundId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoundId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoom
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Players == nil {
				m.Players = make(map[string]*RoundPlayerInfo)
			}
			var mapkey string
			var mapvalue *RoundPlayerInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoom
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoom
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRoom
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthRoom
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoom
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRoom
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthRoom
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RoundPlayerInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoom(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthRoom
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Players[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *R2UGameRoundOver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: R2UGameRoundOver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: R2UGameRoundOver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRoom(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRoom
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRoom
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRoom
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRoom        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRoom          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRoom = fmt.Errorf("proto: unexpected end of group")
)
